import{_ as Q,o as Z,c as j,n as ee,s as te,v as re,a as O}from"./index-DD2Afd_L.js";const ne={name:"LinkIcon",props:{color:{type:String,default:"white"}}},W=e=>(te("data-v-0ca4f93a"),e=e(),re(),e),ae=W(()=>O("path",{d:`M22.8,6.6C22.9,6.3,23,5.9,23,5.5c0-0.9-0.4-1.9-1.2-2.6l-0.7-0.7l0,0c-0.7-0.7-1.5-1.1-2.4-1.1
      c-0.9-0.1-1.7,0.2-2.2,0.8l-5,5c-0.6,0.6-0.8,1.4-0.8,2.2c0.1,0.6,0.3,1.2,0.6,1.8l0.1,0.1l0.1-0.1l1-1l0,0l0-0.1
      c-0.1-0.2-0.1-0.4-0.2-0.6c0-0.4,0.1-0.8,0.4-1l5-5c0.3-0.3,0.7-0.4,1.1-0.4c0.4,0,0.8,0.2,1.2,0.6L20.8,4
      c0.7,0.7,0.8,1.7,0.2,2.2l-5,5c-0.3,0.3-0.6,0.4-1,0.4c-0.2,0-0.4-0.1-0.6-0.2l-0.1,0l0,0l-1,1l-0.1,0.1l0.1,0.1
      c0.5,0.4,1.2,0.6,1.8,0.6c0.9,0.1,1.7-0.2,2.2-0.8l5-5C22.5,7.2,22.7,6.9,22.8,6.6z`},null,-1)),oe=W(()=>O("path",{d:`M13.3,15c0-0.6-0.3-1.2-0.6-1.8l-0.1-0.1l-0.1,0.1l-1,1l0,0l0,0.1c0.1,0.2,0.1,0.4,0.2,0.6
      c0,0.4-0.1,0.8-0.4,1l-5,5c-0.3,0.3-0.7,0.4-1.1,0.4c-0.4,0-0.8-0.2-1.2-0.6L3.2,20c-0.7-0.7-0.8-1.7-0.2-2.2l5-5
      c0.3-0.3,0.6-0.4,1-0.4c0.2,0,0.4,0.1,0.6,0.2l0.1,0l0,0l1-1l0.1-0.1l-0.1-0.1C10.2,11,9.6,10.8,9,10.7c-0.9-0.1-1.7,0.2-2.2,0.8
      l-5,5c-0.3,0.3-0.5,0.6-0.6,0.9C1.1,17.7,1,18.1,1,18.5c0,0.9,0.4,1.9,1.2,2.6l0.7,0.7c0.7,0.7,1.5,1.1,2.4,1.1
      c0.9,0.1,1.7-0.2,2.2-0.8l5-5C13.1,16.6,13.4,15.9,13.3,15z`},null,-1)),ce=W(()=>O("path",{d:`M8.2,15.8C8.3,15.9,8.5,16,8.7,16c0.2,0,0.3-0.1,0.5-0.2l6.7-6.7c0.2-0.2,0.3-0.6,0-0.9
      C15.7,8.1,15.5,8,15.3,8c-0.2,0-0.3,0.1-0.5,0.2l-6.7,6.7C8,15.1,7.9,15.5,8.2,15.8z`},null,-1)),se=[ae,oe,ce];function ie(e,t,r,n,a,c){return Z(),j("svg",{xmlns:"http://www.w3.org/2000/svg",height:"20px",viewBox:"0 0 24 24",width:"20px",class:ee({"fill-white":r.color==="white","fill-theme":r.color==="theme"})},se,2)}const Be=Q(ne,[["render",ie],["__scopeId","data-v-0ca4f93a"]]),P=crypto,M=e=>e instanceof CryptoKey,b=new TextEncoder,_=new TextDecoder;function le(...e){const t=e.reduce((a,{length:c})=>a+c,0),r=new Uint8Array(t);let n=0;for(const a of e)r.set(a,n),n+=a.length;return r}const de=e=>{const t=atob(e),r=new Uint8Array(t.length);for(let n=0;n<t.length;n++)r[n]=t.charCodeAt(n);return r},A=e=>{let t=e;t instanceof Uint8Array&&(t=_.decode(t)),t=t.replace(/-/g,"+").replace(/_/g,"/").replace(/\s/g,"");try{return de(t)}catch{throw new TypeError("The input to be decoded is not correctly encoded.")}};class E extends Error{static get code(){return"ERR_JOSE_GENERIC"}constructor(t){var r;super(t),this.code="ERR_JOSE_GENERIC",this.name=this.constructor.name,(r=Error.captureStackTrace)==null||r.call(Error,this,this.constructor)}}class f extends E{static get code(){return"ERR_JWT_CLAIM_VALIDATION_FAILED"}constructor(t,r,n="unspecified",a="unspecified"){super(t),this.code="ERR_JWT_CLAIM_VALIDATION_FAILED",this.claim=n,this.reason=a,this.payload=r}}class $ extends E{static get code(){return"ERR_JWT_EXPIRED"}constructor(t,r,n="unspecified",a="unspecified"){super(t),this.code="ERR_JWT_EXPIRED",this.claim=n,this.reason=a,this.payload=r}}class ue extends E{constructor(){super(...arguments),this.code="ERR_JOSE_ALG_NOT_ALLOWED"}static get code(){return"ERR_JOSE_ALG_NOT_ALLOWED"}}class y extends E{constructor(){super(...arguments),this.code="ERR_JOSE_NOT_SUPPORTED"}static get code(){return"ERR_JOSE_NOT_SUPPORTED"}}class l extends E{constructor(){super(...arguments),this.code="ERR_JWS_INVALID"}static get code(){return"ERR_JWS_INVALID"}}class V extends E{constructor(){super(...arguments),this.code="ERR_JWT_INVALID"}static get code(){return"ERR_JWT_INVALID"}}class fe extends E{constructor(){super(...arguments),this.code="ERR_JWS_SIGNATURE_VERIFICATION_FAILED",this.message="signature verification failed"}static get code(){return"ERR_JWS_SIGNATURE_VERIFICATION_FAILED"}}function p(e,t="algorithm.name"){return new TypeError(`CryptoKey does not support this operation, its ${t} must be ${e}`)}function g(e,t){return e.name===t}function x(e){return parseInt(e.name.slice(4),10)}function he(e){switch(e){case"ES256":return"P-256";case"ES384":return"P-384";case"ES512":return"P-521";default:throw new Error("unreachable")}}function pe(e,t){if(t.length&&!t.some(r=>e.usages.includes(r))){let r="CryptoKey does not support this operation, its usages must include ";if(t.length>2){const n=t.pop();r+=`one of ${t.join(", ")}, or ${n}.`}else t.length===2?r+=`one of ${t[0]} or ${t[1]}.`:r+=`${t[0]}.`;throw new TypeError(r)}}function me(e,t,...r){switch(t){case"HS256":case"HS384":case"HS512":{if(!g(e.algorithm,"HMAC"))throw p("HMAC");const n=parseInt(t.slice(2),10);if(x(e.algorithm.hash)!==n)throw p(`SHA-${n}`,"algorithm.hash");break}case"RS256":case"RS384":case"RS512":{if(!g(e.algorithm,"RSASSA-PKCS1-v1_5"))throw p("RSASSA-PKCS1-v1_5");const n=parseInt(t.slice(2),10);if(x(e.algorithm.hash)!==n)throw p(`SHA-${n}`,"algorithm.hash");break}case"PS256":case"PS384":case"PS512":{if(!g(e.algorithm,"RSA-PSS"))throw p("RSA-PSS");const n=parseInt(t.slice(2),10);if(x(e.algorithm.hash)!==n)throw p(`SHA-${n}`,"algorithm.hash");break}case"EdDSA":{if(e.algorithm.name!=="Ed25519"&&e.algorithm.name!=="Ed448")throw p("Ed25519 or Ed448");break}case"ES256":case"ES384":case"ES512":{if(!g(e.algorithm,"ECDSA"))throw p("ECDSA");const n=he(t);if(e.algorithm.namedCurve!==n)throw p(n,"algorithm.namedCurve");break}default:throw new TypeError("CryptoKey does not support this operation")}pe(e,r)}function B(e,t,...r){var n;if(r.length>2){const a=r.pop();e+=`one of type ${r.join(", ")}, or ${a}.`}else r.length===2?e+=`one of type ${r[0]} or ${r[1]}.`:e+=`of type ${r[0]}.`;return t==null?e+=` Received ${t}`:typeof t=="function"&&t.name?e+=` Received function ${t.name}`:typeof t=="object"&&t!=null&&(n=t.constructor)!=null&&n.name&&(e+=` Received an instance of ${t.constructor.name}`),e}const D=(e,...t)=>B("Key must be ",e,...t);function F(e,t,...r){return B(`Key for the ${e} algorithm must be `,t,...r)}const z=e=>M(e)?!0:(e==null?void 0:e[Symbol.toStringTag])==="KeyObject",C=["CryptoKey"],Se=(...e)=>{const t=e.filter(Boolean);if(t.length===0||t.length===1)return!0;let r;for(const n of t){const a=Object.keys(n);if(!r||r.size===0){r=new Set(a);continue}for(const c of a){if(r.has(c))return!1;r.add(c)}}return!0};function ye(e){return typeof e=="object"&&e!==null}function K(e){if(!ye(e)||Object.prototype.toString.call(e)!=="[object Object]")return!1;if(Object.getPrototypeOf(e)===null)return!0;let t=e;for(;Object.getPrototypeOf(t)!==null;)t=Object.getPrototypeOf(t);return Object.getPrototypeOf(e)===t}const we=(e,t)=>{if(e.startsWith("RS")||e.startsWith("PS")){const{modulusLength:r}=t.algorithm;if(typeof r!="number"||r<2048)throw new TypeError(`${e} requires key modulusLength to be 2048 bits or larger`)}};function Ee(e){let t,r;switch(e.kty){case"RSA":{switch(e.alg){case"PS256":case"PS384":case"PS512":t={name:"RSA-PSS",hash:`SHA-${e.alg.slice(-3)}`},r=e.d?["sign"]:["verify"];break;case"RS256":case"RS384":case"RS512":t={name:"RSASSA-PKCS1-v1_5",hash:`SHA-${e.alg.slice(-3)}`},r=e.d?["sign"]:["verify"];break;case"RSA-OAEP":case"RSA-OAEP-256":case"RSA-OAEP-384":case"RSA-OAEP-512":t={name:"RSA-OAEP",hash:`SHA-${parseInt(e.alg.slice(-3),10)||1}`},r=e.d?["decrypt","unwrapKey"]:["encrypt","wrapKey"];break;default:throw new y('Invalid or unsupported JWK "alg" (Algorithm) Parameter value')}break}case"EC":{switch(e.alg){case"ES256":t={name:"ECDSA",namedCurve:"P-256"},r=e.d?["sign"]:["verify"];break;case"ES384":t={name:"ECDSA",namedCurve:"P-384"},r=e.d?["sign"]:["verify"];break;case"ES512":t={name:"ECDSA",namedCurve:"P-521"},r=e.d?["sign"]:["verify"];break;case"ECDH-ES":case"ECDH-ES+A128KW":case"ECDH-ES+A192KW":case"ECDH-ES+A256KW":t={name:"ECDH",namedCurve:e.crv},r=e.d?["deriveBits"]:[];break;default:throw new y('Invalid or unsupported JWK "alg" (Algorithm) Parameter value')}break}case"OKP":{switch(e.alg){case"EdDSA":t={name:e.crv},r=e.d?["sign"]:["verify"];break;case"ECDH-ES":case"ECDH-ES+A128KW":case"ECDH-ES+A192KW":case"ECDH-ES+A256KW":t={name:e.crv},r=e.d?["deriveBits"]:[];break;default:throw new y('Invalid or unsupported JWK "alg" (Algorithm) Parameter value')}break}default:throw new y('Invalid or unsupported JWK "kty" (Key Type) Parameter value')}return{algorithm:t,keyUsages:r}}const be=async e=>{if(!e.alg)throw new TypeError('"alg" argument is required when "jwk.alg" is not present');const{algorithm:t,keyUsages:r}=Ee(e),n=[t,e.ext??!1,e.key_ops??r],a={...e};return delete a.alg,delete a.use,P.subtle.importKey("jwk",a,...n)},G=e=>A(e);let T,I;const q=e=>(e==null?void 0:e[Symbol.toStringTag])==="KeyObject",k=async(e,t,r,n)=>{let a=e.get(t);if(a!=null&&a[n])return a[n];const c=await be({...r,alg:n});return a?a[n]=c:e.set(t,{[n]:c}),c},ge=(e,t)=>{if(q(e)){let r=e.export({format:"jwk"});return delete r.d,delete r.dp,delete r.dq,delete r.p,delete r.q,delete r.qi,r.k?G(r.k):(I||(I=new WeakMap),k(I,e,r,t))}return e},Ae=(e,t)=>{if(q(e)){let r=e.export({format:"jwk"});return r.k?G(r.k):(T||(T=new WeakMap),k(T,e,r,t))}return e},ve={normalizePublicKey:ge,normalizePrivateKey:Ae},S=(e,t,r=0)=>{r===0&&(t.unshift(t.length),t.unshift(6));const n=e.indexOf(t[0],r);if(n===-1)return!1;const a=e.subarray(n,n+t.length);return a.length!==t.length?!1:a.every((c,o)=>c===t[o])||S(e,t,n+1)},L=e=>{switch(!0){case S(e,[42,134,72,206,61,3,1,7]):return"P-256";case S(e,[43,129,4,0,34]):return"P-384";case S(e,[43,129,4,0,35]):return"P-521";case S(e,[43,101,110]):return"X25519";case S(e,[43,101,111]):return"X448";case S(e,[43,101,112]):return"Ed25519";case S(e,[43,101,113]):return"Ed448";default:throw new y("Invalid or unsupported EC Key Curve or OKP Key Sub Type")}},Ce=async(e,t,r,n,a)=>{let c,o;const s=new Uint8Array(atob(r.replace(e,"")).split("").map(i=>i.charCodeAt(0)));switch(n){case"PS256":case"PS384":case"PS512":c={name:"RSA-PSS",hash:`SHA-${n.slice(-3)}`},o=["verify"];break;case"RS256":case"RS384":case"RS512":c={name:"RSASSA-PKCS1-v1_5",hash:`SHA-${n.slice(-3)}`},o=["verify"];break;case"RSA-OAEP":case"RSA-OAEP-256":case"RSA-OAEP-384":case"RSA-OAEP-512":c={name:"RSA-OAEP",hash:`SHA-${parseInt(n.slice(-3),10)||1}`},o=["encrypt","wrapKey"];break;case"ES256":c={name:"ECDSA",namedCurve:"P-256"},o=["verify"];break;case"ES384":c={name:"ECDSA",namedCurve:"P-384"},o=["verify"];break;case"ES512":c={name:"ECDSA",namedCurve:"P-521"},o=["verify"];break;case"ECDH-ES":case"ECDH-ES+A128KW":case"ECDH-ES+A192KW":case"ECDH-ES+A256KW":{const i=L(s);c=i.startsWith("P-")?{name:"ECDH",namedCurve:i}:{name:i},o=[];break}case"EdDSA":c={name:L(s)},o=["verify"];break;default:throw new y('Invalid or unsupported "alg" (Algorithm) value')}return P.subtle.importKey(t,s,c,!1,o)},Pe=(e,t,r)=>Ce(/(?:-----(?:BEGIN|END) PUBLIC KEY-----|\s)/g,"spki",e,t);async function Fe(e,t,r){if(typeof e!="string"||e.indexOf("-----BEGIN PUBLIC KEY-----")!==0)throw new TypeError('"spki" must be SPKI formatted string');return Pe(e,t)}const v=e=>e==null?void 0:e[Symbol.toStringTag],_e=(e,t)=>{if(!(t instanceof Uint8Array)){if(!z(t))throw new TypeError(F(e,t,...C,"Uint8Array"));if(t.type!=="secret")throw new TypeError(`${v(t)} instances for symmetric algorithms must be of type "secret"`)}},Re=(e,t,r)=>{if(!z(t))throw new TypeError(F(e,t,...C));if(t.type==="secret")throw new TypeError(`${v(t)} instances for asymmetric algorithms must not be of type "secret"`);if(t.algorithm&&r==="verify"&&t.type==="private")throw new TypeError(`${v(t)} instances for asymmetric algorithm verifying must be of type "public"`);if(t.algorithm&&r==="encrypt"&&t.type==="private")throw new TypeError(`${v(t)} instances for asymmetric algorithm encryption must be of type "public"`)},xe=(e,t,r)=>{e.startsWith("HS")||e==="dir"||e.startsWith("PBES2")||/^A\d{3}(?:GCM)?KW$/.test(e)?_e(e,t):Re(e,t,r)};function Te(e,t,r,n,a){if(a.crit!==void 0&&(n==null?void 0:n.crit)===void 0)throw new e('"crit" (Critical) Header Parameter MUST be integrity protected');if(!n||n.crit===void 0)return new Set;if(!Array.isArray(n.crit)||n.crit.length===0||n.crit.some(o=>typeof o!="string"||o.length===0))throw new e('"crit" (Critical) Header Parameter MUST be an array of non-empty strings when present');let c;r!==void 0?c=new Map([...Object.entries(r),...t.entries()]):c=t;for(const o of n.crit){if(!c.has(o))throw new y(`Extension Header Parameter "${o}" is not recognized`);if(a[o]===void 0)throw new e(`Extension Header Parameter "${o}" is missing`);if(c.get(o)&&n[o]===void 0)throw new e(`Extension Header Parameter "${o}" MUST be integrity protected`)}return new Set(n.crit)}const Ie=(e,t)=>{if(t!==void 0&&(!Array.isArray(t)||t.some(r=>typeof r!="string")))throw new TypeError(`"${e}" option must be an array of strings`);if(t)return new Set(t)};function Ke(e,t){const r=`SHA-${e.slice(-3)}`;switch(e){case"HS256":case"HS384":case"HS512":return{hash:r,name:"HMAC"};case"PS256":case"PS384":case"PS512":return{hash:r,name:"RSA-PSS",saltLength:e.slice(-3)>>3};case"RS256":case"RS384":case"RS512":return{hash:r,name:"RSASSA-PKCS1-v1_5"};case"ES256":case"ES384":case"ES512":return{hash:r,name:"ECDSA",namedCurve:t.namedCurve};case"EdDSA":return{name:t.name};default:throw new y(`alg ${e} is not supported either by JOSE or your javascript runtime`)}}async function Oe(e,t,r){if(t=await ve.normalizePublicKey(t,e),M(t))return me(t,e,r),t;if(t instanceof Uint8Array){if(!e.startsWith("HS"))throw new TypeError(D(t,...C));return P.subtle.importKey("raw",t,{hash:`SHA-${e.slice(-3)}`,name:"HMAC"},!1,[r])}throw new TypeError(D(t,...C,"Uint8Array"))}const We=async(e,t,r,n)=>{const a=await Oe(e,t,"verify");we(e,a);const c=Ke(e,a.algorithm);try{return await P.subtle.verify(c,a,r,n)}catch{return!1}};async function Je(e,t,r){if(!K(e))throw new l("Flattened JWS must be an object");if(e.protected===void 0&&e.header===void 0)throw new l('Flattened JWS must have either of the "protected" or "header" members');if(e.protected!==void 0&&typeof e.protected!="string")throw new l("JWS Protected Header incorrect type");if(e.payload===void 0)throw new l("JWS Payload missing");if(typeof e.signature!="string")throw new l("JWS Signature missing or incorrect type");if(e.header!==void 0&&!K(e.header))throw new l("JWS Unprotected Header incorrect type");let n={};if(e.protected)try{const R=A(e.protected);n=JSON.parse(_.decode(R))}catch{throw new l("JWS Protected Header is invalid")}if(!Se(n,e.header))throw new l("JWS Protected and JWS Unprotected Header Parameter names must be disjoint");const a={...n,...e.header},c=Te(l,new Map([["b64",!0]]),r==null?void 0:r.crit,n,a);let o=!0;if(c.has("b64")&&(o=n.b64,typeof o!="boolean"))throw new l('The "b64" (base64url-encode payload) Header Parameter must be a boolean');const{alg:s}=a;if(typeof s!="string"||!s)throw new l('JWS "alg" (Algorithm) Header Parameter missing or invalid');const i=r&&Ie("algorithms",r.algorithms);if(i&&!i.has(s))throw new ue('"alg" (Algorithm) Header Parameter value not allowed');if(o){if(typeof e.payload!="string")throw new l("JWS Payload must be a string")}else if(typeof e.payload!="string"&&!(e.payload instanceof Uint8Array))throw new l("JWS Payload must be a string or an Uint8Array instance");let h=!1;typeof t=="function"&&(t=await t(n,e),h=!0),xe(s,t,"verify");const w=le(b.encode(e.protected??""),b.encode("."),typeof e.payload=="string"?b.encode(e.payload):e.payload);let u;try{u=A(e.signature)}catch{throw new l("Failed to base64url decode the signature")}if(!await We(s,t,u,w))throw new fe;let m;if(o)try{m=A(e.payload)}catch{throw new l("Failed to base64url decode the payload")}else typeof e.payload=="string"?m=b.encode(e.payload):m=e.payload;const d={payload:m};return e.protected!==void 0&&(d.protectedHeader=n),e.header!==void 0&&(d.unprotectedHeader=e.header),h?{...d,key:t}:d}async function He(e,t,r){if(e instanceof Uint8Array&&(e=_.decode(e)),typeof e!="string")throw new l("Compact JWS must be a string or Uint8Array");const{0:n,1:a,2:c,length:o}=e.split(".");if(o!==3)throw new l("Invalid Compact JWS");const s=await Je({payload:a,protected:n,signature:c},t,r),i={payload:s.payload,protectedHeader:s.protectedHeader};return typeof t=="function"?{...i,key:s.key}:i}const $e=e=>Math.floor(e.getTime()/1e3),X=60,Y=X*60,J=Y*24,De=J*7,Le=J*365.25,Ne=/^(\+|\-)? ?(\d+|\d+\.\d+) ?(seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)(?: (ago|from now))?$/i,N=e=>{const t=Ne.exec(e);if(!t||t[4]&&t[1])throw new TypeError("Invalid time period format");const r=parseFloat(t[2]),n=t[3].toLowerCase();let a;switch(n){case"sec":case"secs":case"second":case"seconds":case"s":a=Math.round(r);break;case"minute":case"minutes":case"min":case"mins":case"m":a=Math.round(r*X);break;case"hour":case"hours":case"hr":case"hrs":case"h":a=Math.round(r*Y);break;case"day":case"days":case"d":a=Math.round(r*J);break;case"week":case"weeks":case"w":a=Math.round(r*De);break;default:a=Math.round(r*Le);break}return t[1]==="-"||t[4]==="ago"?-a:a},U=e=>e.toLowerCase().replace(/^application\//,""),Ue=(e,t)=>typeof e=="string"?t.includes(e):Array.isArray(e)?t.some(Set.prototype.has.bind(new Set(e))):!1,Me=(e,t,r={})=>{let n;try{n=JSON.parse(_.decode(t))}catch{}if(!K(n))throw new V("JWT Claims Set must be a top-level JSON object");const{typ:a}=r;if(a&&(typeof e.typ!="string"||U(e.typ)!==U(a)))throw new f('unexpected "typ" JWT header value',n,"typ","check_failed");const{requiredClaims:c=[],issuer:o,subject:s,audience:i,maxTokenAge:h}=r,w=[...c];h!==void 0&&w.push("iat"),i!==void 0&&w.push("aud"),s!==void 0&&w.push("sub"),o!==void 0&&w.push("iss");for(const d of new Set(w.reverse()))if(!(d in n))throw new f(`missing required "${d}" claim`,n,d,"missing");if(o&&!(Array.isArray(o)?o:[o]).includes(n.iss))throw new f('unexpected "iss" claim value',n,"iss","check_failed");if(s&&n.sub!==s)throw new f('unexpected "sub" claim value',n,"sub","check_failed");if(i&&!Ue(n.aud,typeof i=="string"?[i]:i))throw new f('unexpected "aud" claim value',n,"aud","check_failed");let u;switch(typeof r.clockTolerance){case"string":u=N(r.clockTolerance);break;case"number":u=r.clockTolerance;break;case"undefined":u=0;break;default:throw new TypeError("Invalid clockTolerance option type")}const{currentDate:H}=r,m=$e(H||new Date);if((n.iat!==void 0||h)&&typeof n.iat!="number")throw new f('"iat" claim must be a number',n,"iat","invalid");if(n.nbf!==void 0){if(typeof n.nbf!="number")throw new f('"nbf" claim must be a number',n,"nbf","invalid");if(n.nbf>m+u)throw new f('"nbf" claim timestamp check failed',n,"nbf","check_failed")}if(n.exp!==void 0){if(typeof n.exp!="number")throw new f('"exp" claim must be a number',n,"exp","invalid");if(n.exp<=m-u)throw new $('"exp" claim timestamp check failed',n,"exp","check_failed")}if(h){const d=m-n.iat,R=typeof h=="number"?h:N(h);if(d-u>R)throw new $('"iat" claim timestamp check failed (too far in the past)',n,"iat","check_failed");if(d<0-u)throw new f('"iat" claim timestamp check failed (it should be in the past)',n,"iat","check_failed")}return n};async function ze(e,t,r){var o;const n=await He(e,t,r);if((o=n.protectedHeader.crit)!=null&&o.includes("b64")&&n.protectedHeader.b64===!1)throw new V("JWTs MUST NOT use unencoded payload");const c={payload:Me(n.protectedHeader,n.payload,r),protectedHeader:n.protectedHeader};return typeof t=="function"?{...c,key:n.key}:c}export{Be as _,Fe as i,ze as j};
